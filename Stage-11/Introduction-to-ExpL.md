# Stage 11

```ad-abstract
- Familiarise with the use of ExpL for writing application programs
- Familiarise with the ExpL high level library interface
```

```ad-info
Read and understand the

1. [ExpL Specification](https://exposnitc.github.io/expos-docs/support-tools/expl/)
2. [ExpL high level library interface](https://exposnitc.github.io/expos-docs/os-spec/dynamicmemoryroutines/) before proceeding further.

 ⚠ Read only the specification just enough to write simple programs in the language. Don't get lost in the links
```

---

ExpL is a high level language in which you can write high level application programs. A compiler for ExpL supplied to you along with the eXpOS package will generate target code compatible with the eXpOS specification.

ExpL permits application programs to call the function exposcall() that implements the [high level library interface](https://exposnitc.github.io/expos-docs/os-spec/dynamicmemoryroutines/) to the OS. Application programs must use this library interface to invoke eXpOS system calls. Certain built-in functions of the ExpL language (Alloc, Free and Initialize - these functions handle ExpL dynamic memory management) are also implemented as ExpL library routines. Note that the only way to invoke an eXpOS system call from a high level ExpL program is to use the exposcall() function.

The ExpL library file library.lib supplied to you along with the eXpOS package contains assembly language implementation of the library and occupies two pages of memory. The OS design stipulates that this library code must be pre-loaded to the XSM disk blocks 13 and 14 before OS bootstrap using XFS interface (see [disk layout](https://exposnitc.github.io/expos-docs/os-implementation/)). Your OS start up code is supposed to load this code into memory pages 63 and 64 from disk blocks 13 and 14.

An ExpL program written by a programmer will contain library calls using the exposcall() function. The ExpL compiler will translate these calls to assembly instructions calling the library as specified [here](https://exposnitc.github.io/expos-docs/abi/) (see**low level runtime library interface**).

The compiler expects that the library will be loaded to the **logical address 0**of the address space of the program. The target code generated by the compiler will not contain the code for the library. Instead, the OS is expected to link this code (at physical pages 63 and 64) into logical pages 0 and 1 when the program is loaded for execution.

Hence, when the OS loads a program for execution, the library code must be linked to the logical pages 0 and 1 by setting the page table entries for the first two logical pages to 63 and 64. An ExpL program will contain calls to the library and hence the library linkage must be done correctly for ExpL program to run properly.

In the previous stages, you wrote and executed application programs in assembly language. Now, you will write application programs in ExpL and compile it to generate the assembly program. This compiled code is loaded into the XSM disk as done in previous stages.

1) Below is the ExpL program to print numbers upto 50. Save this program as numbers.expl in `$HOME/myexpos/eXpl/samples.` This will be the init program in this stage.

```c
int main()
{
decl
    int temp,num;
enddecl
begin
    num=1;
    while ( num <= 50 ) do
         temp = exposcall ( "Write" , -2, num );
         num = num + 1;
    endwhile;
    return 0;
end
}
```

Refer [here](http://silcnitc.github.io/testprograms.html) for more examples of ExpL programs.

2) Compile this program using the command

```bash
cd $HOME/myexpos/eXpl
./expl samples/numbers.expl
```

The ExpL compiler will write the target executable code into the file assemblycode.xsm. (You will have to save the file to a different name before compiling the next ExpL program).

```ad-note
The present version of ExpL compiles `<filename>.expl` into `<filename>.xsm`. A copy of this target file is also wriiten into the file `assemblycode.xsm` for backward compatibility.
```

3) Load the compiled code as the init program into the XSM disk using XFS Interface.

4) Run the XSM machine.

---

```ad-question
Q1. If your ExpL program contains read() function call, will it work now?
```
```ad-info
title: Answer
Obviously not. The ExpL compiler will generate a call to the library requesting a console read; the library code in turn will generate an INT 6 for console input. Since you haven't written any code for INT 6, the OS will crash in INT 6. It will be an insightful exercise to trace the sequence of calls in debug mode.
```

---
# Assignment 1

```ad-question
title: Question 1
Write an ExpL program to print all odd numbers from 1-100 and run the machine with this program loaded as the init.
```

## Modifications
```c
int main()
{
decl
    int temp,num,check;
enddecl
begin
    num=1;
    while ( num <= 100 ) do
    	 check = num%2;
    	 if( check != 0) then
	         temp = exposcall ( "Write" , -2, num );
         endif;
         num = num + 1;
    endwhile;
    return 0;
end
}
```

$$ OR $$
```c
int main()
{
decl
    int temp,num,check;
enddecl
begin
    num=1;
    while ( num <= 100 ) do
    	 check = num%2;
    	 if( check != 0) then
	         write(num);
         endif;
         num = num + 1;
    endwhile;
    return 0;
end
}
```


---

# Assignment 2
```ad-question
title: Question 2
Write an ExpL program to include a user defined type _Student_ as follows


	Student
	{
	str name;
	int marks;
	}




Declare a variable of type Student, assign values "John", 89 for name and marks respectively and print the values to the terminal. Run the machine with this as an init program. Don't forget to initialize the heap and allocate the memory for a variable before assigning values to its attributes.
```

```c
type
Student
{
	str name;
	int marks;
}
endtype

int main(){
	decl
		Student s;
		int tmp,disp;
	enddecl

	begin
		s = null;
		tmp = initialize();
		s = alloc();

		s.name = "John";
		s.marks = 89;
		
		disp = exposcall ( "Write" , -2, s.name );
		disp = exposcall ( "Write" , -2, s.marks );

		return 0;
	end
}
```

$$ OR $$
```c
type
Student
{
	str name;
	int marks;
}
endtype

int main(){
	decl
		Student s;
		int tmp;
	enddecl

	begin
		s = null;
		tmp = initialize();
		s = alloc();

		s.name = "John";
		s.marks = 89;

		write(s.name);
		write(s.marks);
		return 0;
	end
}
```

---

# Assignment 3
```ad-question
title: Question 3
Instead of using the library implementation `library.lib`, write your own library (in assembly language) to support only the write system call to console. Your library code must extract arguments from the stack, check whether the request is for a console write, if so call INT 7 after supplying proper arguments in the stack as done in the previous stage. Upon return from the system call, your library routine must set the return value through the stack (setting return value in the proper location of the stack -see details [here](https://exposnitc.github.io/expos-docs/abi/#low-level-runtime-library-interface) ) and return control back to the application.
```

HOW ?????